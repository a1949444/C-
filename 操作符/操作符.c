#define  _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>

//1./  除号   1/2 两边都是整数，得到的是整除法 得到的是整数部分商  1/2-->商0余1  结果为0
//int main() {
//	int i = 0;
//	i = 1 / 2;
//	printf("%d", i);
//	return 0;
//}

//2.%  取模符号   得到的是余数   1%2   商0余1   结果为1
//int main() {
//	int i = 0;
//	i = 1 % 2;
//	printf("%d", i);
//	return 0;
//}

//3.移位操作符  >>右移操作法（1.算术右移  2.逻辑右移）  <<(左移操作符：左边丢弃，右边补0)    移动的是二进制位
//int main() {
//	int a = 16;
//	//十进制：16    16 = 2 ^ 4
//	//	    --
//	//二进制：10000
//	//正数在内存中的储存的是补码，正数的原码 = 反码 = 补码：00000000000000000000000000010000      （32位）
//	int b = a >> 1;   //整体向右移动一位   每右移一位  原来的数除以2
//	//算术右移：右边丢弃，左边补原符号（正数最高位符号位为0，负数最高位符号位为1）
//	//16是正数，左边补0  --> 00000000000000000000000000001000 -->2^3=8
//
//	//逻辑右移：右边丢弃，左边补0    --> 00000000000000000000000000001000
//	printf("%d", b);
//
//	return 0;
//}
//
//int main() {
//	int a = -1;
//	//负数的移位操作
//	int b = a >> 1;
//	//负数的补码=原码除了最高符号位，其他位置按位取反+1
//	//-1的原码（32位）  10000000000000000000000000000001    最高位是1表示负数  
//	//除符号位按位取反  11111111111111111111111111111110      反码        
//	                  //00000000000000000000000000000001       +1
//	//-1的补码          11111111111111111111111111111111       
////-1的补码右边丢弃，左边补原符号位
//	                  //11111111111111111111111111111111      b的补码=a的补码   b=a=-1
//	printf("%d", b);
//	return 0;
//}


//int main() {
//	int i = 16;
//	int j = i << 1;
//	/*二进制补码：                 00000000000000000000000000010000
//	左移规则：左边丢弃，右边补0：  00000000000000000000000000100000  -- > 2 ^ 5 = 32*/
//	printf("%d", j);
//	return 0;
//
// }

//按位与& ：两个二进制数只要有一个是0则为0
//int main() {
//	int a = 5;
//	int b = 3;
//	int c = a & b;
//	int d = -1;
//	int e = d & a;
////注意：是对两个数的补码进行运算
////a:	00000000000000000000000000000101
////b :   00000000000000000000000000000011
////      --------------------------------
////c :   00000000000000000000000000000001
////d的原码:          10000000000000000000000000000001        -1
////除符号位按位取反：11111111111111111111111111111110        反码
////                  00000000000000000000000000000001        +1               
////	d的补码：       11111111111111111111111111111111 
////	a ：            00000000000000000000000000000101
////	e=d&a           00000000000000000000000000000101         5
//printf("%d\n", c);
//printf("%d\n", e);
//	return 0;
//}


////按位或|:只要有一个为1则为1
//int main() {
//	int a = 5;
//	int b = 3;
//	int c = a | b;
//	//  a的补码：00000000000000000000000000000101
//	//	b的补码：00000000000000000000000000000011
//	//	按位或： 00000000000000000000000000000111     7
//		printf("%d\n", c);
//
//	return 0;
//}


//按位异或^:两个二进制数相同为0，相异为1
//int main() {
//	int a = 3;
//	int b = 5;
//	int c = a ^ b;
//	/*a的补码：00000000000000000000000000000101
//	b的补码：  00000000000000000000000000000011
//	按位异或： 00000000000000000000000000000110      6*/
//	printf("%d\n", c);
//	return 0;
//}

//使用按位异或的方法调换两个变量之间的值
//原理：两个数进行按位异或得到的第三个数（密钥），只要两个数中的其中一个数按位异或第三个数就会得到两个数中的另一个数
//int main() {
//	int a = 5;
//	int b = 3;
//	printf("替换前：a=%d,b=%d\n", a, b);
//    a = a ^ b;     //将a^b的结果先放在a的地方（存放着两个数按位异或的结果（密钥））
//	b = a ^ b;     //b^a==b按位异或密钥  -->得到原始a  将原始a的值放在b处，完成了将b的值替换成a
//	a = a ^ b;     //将密钥a按位异或b（存放的是原始a的值）  -->得到原始b的值赋值给a变量
//	printf("替换后：a=%d,b=%d\n", a, b);
//	return 0;
//}


//练习一：计算给定数字的二进制数（补码）中有多少个1
//方法一（只能计算正数）：使用%2然后/2的方法 （参考计算十进制中有多少个1的方法：十进制%10-->/10）
//例：要找出1234中每个数字的值是多少的方法：1. 用1234%10  -->得到的是个位的余数4，得到之后用1234/10 -->得到123，循环直到所有数都找出来(数值的位数为0)
//仿例：要找出1234的二进制位中有多少个1:二进制%2--->/2
//int main() {
//	int num = 0;
//	int count = 0;
//	printf("请输入你要查找的二进制数(补码)中有多少个1的数字：");
//	scanf("%d", &num);  //如果输入-1
//	while (num)
//	{
//		if (num % 2 == 1)    //-1%2--->商0余-1，不进入循环
//		{
//			count++;
//		}
//		num=num / 2;      //-1/2=0    ，结果为0个1  ，实际上-1的补码有32个1
//	}
//	printf("一共有%d个1\n",count);
//	return 0;
//}

//方法二：使用移位操作符,一共循环32次，不用担心负数左边补1会多出的情况
//a=-3
//a的二进制补码 10000000000000000000000000000011
//              00000000000000000000000000000001   //1.让a按位与1  如果1对应的位置是0结果为0，如果对应位置是1结果为1
//	            00000000000000000000000000000001      
//	          ->10000000000000000000000000000011    //2.让a右移一位
//	            11000000000000000000000000000001       //右边舍弃，左边补原符号位


//int main() {
//	int num = 0;
//	int i = 0;
//	int count = 0;
//	printf("请输入数字：");
//	scanf("%d", &num);
//	for (i = 0; i < 32; i++)
//	{
//		if (1 == ((num >> i) & 1))    //num的值不变，是在原始输入num的基础上增加移位次数进行count++操作
//		{
//			count++;
//		}
//	}
//	printf("%d中一共有%d个1\n", num, count);
//	return 0;
//}

//没看懂！！！！！！！！！！！！！！！！！！！！！！！！！！！
int main() {
	int count = 0;
	int num = 0;
	printf("请输入数字：");
	scanf("%d", &num);
	while (num)     
	{
		count++;
		num = num & (num - 1);
	}
	printf("%d", count);
	return 0;
}

//单目操作符 ！  反操作符
//int main() {
//	int a = 0;
//	if (!a)   //此时a为假，！a为真，打印
//	{
//		printf("哈哈\n");
//	}
//	if (a)   //此时a为0，a为假，不打印
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}

//int main() {
//	char arr1[10] = "abc";
//	char arr2[] = { 'a','b','c' };
//	char c = 'r';      
//	int sz2 = sizeof(c);
//	//int sz2 = sizeof(char);   与上面等价
//	//int sz2 = sizeof c;      //sizeof可以直接接变量名，不用括号
//	//int sz2 = sizeof char;    //不可以sizeof直接接类型，需要写括号
//	printf("sz2=%d\n", sz2);   //单个字符没有结束符\0
//	int sz1 = sizeof(arr1);  //字符串abc有默认的结束符\0  也占有空间
//	//int sz1 = sizeof(char[10]);  //数组的类型是 除去arr数组名的部分  char [10]是arr1的类型
//	int str1 = strlen(arr1);   //strlen函数不会计算结束符\0的个数，计算字符串个数计算到\0停止
//	printf("sz1=%d,str1=%d", sz1, str1);
//	return 0;
//}